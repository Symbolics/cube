
(in-package :cube)


(defun create-namespaced-binding (binding namespace &key pretty)
  "create a Binding

    [*] pretty: If 'true', then the output is pretty printed.

    [!] binding: A value of type BINDING

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type binding binding)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/bindings" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s binding)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-component-status
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list objects of kind ComponentStatus

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/componentstatuses")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-component-status (name &key pretty)
  "read the specified ComponentStatus

    [*] pretty: If 'true', then the output is pretty printed.

    [!] name: name of the ComponentStatus"
  (check-type pretty (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/componentstatuses/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-config-map
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/configmaps" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-config-map (config-map namespace &key pretty)
  "create a ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [!] config-map: A value of type CONFIG-MAP

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type config-map config-map)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/configmaps" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s config-map)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-config-map
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/configmaps" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-config-map-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/watch/namespaces/~A/configmaps" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-config-map (namespace name &key pretty export exact)
  "read the specified ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ConfigMap"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/configmaps/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-config-map (config-map namespace name &key pretty)
  "replace the specified ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [!] config-map: A value of type CONFIG-MAP

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ConfigMap"
  (check-type pretty (or string null))
  (check-type config-map config-map)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/configmaps/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s config-map)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-config-map (patch namespace name &key pretty)
  "partially update the specified ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ConfigMap"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/configmaps/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-config-map
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ConfigMap"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/configmaps/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-config-map
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ConfigMap"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/configmaps/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-config-map-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/configmaps")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-config-map-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ConfigMap

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/configmaps")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-namespaced-endpoints
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/endpoints" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-endpoints (endpoints namespace &key pretty)
  "create Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [!] endpoints: A value of type ENDPOINTS

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type endpoints endpoints)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/endpoints" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s endpoints)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-endpoints
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/endpoints" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-endpoints-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/watch/namespaces/~A/endpoints" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-endpoints (namespace name &key pretty export exact)
  "read the specified Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Endpoints"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/endpoints/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-endpoints (endpoints namespace name &key pretty)
  "replace the specified Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [!] endpoints: A value of type ENDPOINTS

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Endpoints"
  (check-type pretty (or string null))
  (check-type endpoints endpoints)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/endpoints/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s endpoints)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-endpoints (patch namespace name &key pretty)
  "partially update the specified Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Endpoints"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/endpoints/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-endpoints
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Endpoints"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/endpoints/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-endpoints
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Endpoints"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/endpoints/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-endpoints-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/endpoints")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-endpoints-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Endpoints

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/endpoints")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-namespaced-event
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Event

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/events" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-event (event namespace &key pretty)
  "create an Event

    [*] pretty: If 'true', then the output is pretty printed.

    [!] event: A value of type EVENT

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type event event)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/events" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s event)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-event
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of Event

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/events" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-event-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Event

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/watch/namespaces/~A/events" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-event (namespace name &key pretty export exact)
  "read the specified Event

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Event"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/events/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-event (event namespace name &key pretty)
  "replace the specified Event

    [*] pretty: If 'true', then the output is pretty printed.

    [!] event: A value of type EVENT

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Event"
  (check-type pretty (or string null))
  (check-type event event)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/events/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s event)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-event (patch namespace name &key pretty)
  "partially update the specified Event

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Event"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/events/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-event
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete an Event

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Event"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/events/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-event
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind Event

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Event"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/events/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-event-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Event

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/events")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-event-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Event

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/events")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-namespaced-limit-range
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/limitranges" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-limit-range (limit-range namespace &key pretty)
  "create a LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [!] limit-range: A value of type LIMIT-RANGE

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type limit-range limit-range)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/limitranges" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s limit-range)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-limit-range
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/limitranges" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-limit-range-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/limitranges" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-limit-range (namespace name &key pretty export exact)
  "read the specified LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the LimitRange"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/limitranges/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-limit-range (limit-range namespace name &key pretty)
  "replace the specified LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [!] limit-range: A value of type LIMIT-RANGE

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the LimitRange"
  (check-type pretty (or string null))
  (check-type limit-range limit-range)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/limitranges/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s limit-range)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-limit-range (patch namespace name &key pretty)
  "partially update the specified LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the LimitRange"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/limitranges/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-limit-range
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the LimitRange"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/limitranges/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-limit-range
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the LimitRange"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/limitranges/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-limit-range-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/limitranges")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-limit-range-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of LimitRange

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/limitranges")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-namespace
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/namespaces")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespace (namespace &key pretty)
  "create a Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: A value of type NAMESPACE"
  (check-type pretty (or string null))
  (check-type namespace namespace)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/namespaces")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s namespace)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespace-list
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/namespaces")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespace (name &key pretty export exact)
  "read the specified Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] name: name of the Namespace"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespace (namespace name &key pretty)
  "replace the specified Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: A value of type NAMESPACE

    [!] name: name of the Namespace"
  (check-type pretty (or string null))
  (check-type namespace namespace)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s namespace)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespace (patch name &key pretty)
  "partially update the specified Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] name: name of the Namespace"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespace
       (delete-options name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] name: name of the Namespace"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespace
       (name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] name: name of the Namespace"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/watch/namespaces/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun replace-namespace-finalize (namespace name &key pretty)
  "replace finalize of the specified Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: A value of type NAMESPACE

    [!] name: name of the Namespace"
  (check-type pretty (or string null))
  (check-type namespace namespace)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/finalize" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s namespace)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-namespace-status (name &key pretty)
  "read status of the specified Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [!] name: name of the Namespace"
  (check-type pretty (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/status" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespace-status (namespace name &key pretty)
  "replace status of the specified Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: A value of type NAMESPACE

    [!] name: name of the Namespace"
  (check-type pretty (or string null))
  (check-type namespace namespace)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/status" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s namespace)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespace-status (patch name &key pretty)
  "partially update status of the specified Namespace

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] name: name of the Namespace"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/status" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-node
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Node

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/nodes")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-node (node &key pretty)
  "create a Node

    [*] pretty: If 'true', then the output is pretty printed.

    [!] node: A value of type NODE"
  (check-type pretty (or string null))
  (check-type node node)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/nodes")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s node)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-node
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of Node

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/nodes")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-node-list
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Node

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/nodes")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-node (name &key pretty export exact)
  "read the specified Node

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] name: name of the Node"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-node (node name &key pretty)
  "replace the specified Node

    [*] pretty: If 'true', then the output is pretty printed.

    [!] node: A value of type NODE

    [!] name: name of the Node"
  (check-type pretty (or string null))
  (check-type node node)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s node)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-node (patch name &key pretty)
  "partially update the specified Node

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] name: name of the Node"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-node
       (delete-options name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a Node

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] name: name of the Node"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-node
       (name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind Node

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] name: name of the Node"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/watch/nodes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun connect-get-node-proxy (name &key path)
  "connect GET requests to proxy of Node

    [*] path: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node"
  (check-type path (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy" name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-post-node-proxy (name &key path)
  "connect POST requests to proxy of Node

    [*] path: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node"
  (check-type path (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy" name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-put-node-proxy (name &key path)
  "connect PUT requests to proxy of Node

    [*] path: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node"
  (check-type path (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy" name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-patch-node-proxy (name &key path)
  "connect PATCH requests to proxy of Node

    [*] path: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node"
  (check-type path (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy" name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-delete-node-proxy (name &key path)
  "connect DELETE requests to proxy of Node

    [*] path: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node"
  (check-type path (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy" name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-head-node-proxy (name &key path)
  "connect HEAD requests to proxy of Node

    [*] path: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node"
  (check-type path (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy" name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :head :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-options-node-proxy (name &key path)
  "connect OPTIONS requests to proxy of Node

    [*] path: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node"
  (check-type path (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy" name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :options :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun connect-get-node-proxy-with-path (name path2 &key path1)
  "connect GET requests to proxy of Node

    [*] path1: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy/~A" name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-post-node-proxy-with-path (name path2 &key path1)
  "connect POST requests to proxy of Node

    [*] path1: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy/~A" name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-put-node-proxy-with-path (name path2 &key path1)
  "connect PUT requests to proxy of Node

    [*] path1: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy/~A" name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-patch-node-proxy-with-path (name path2 &key path1)
  "connect PATCH requests to proxy of Node

    [*] path1: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy/~A" name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-delete-node-proxy-with-path (name path2 &key path1)
  "connect DELETE requests to proxy of Node

    [*] path1: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy/~A" name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-head-node-proxy-with-path (name path2 &key path1)
  "connect HEAD requests to proxy of Node

    [*] path1: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy/~A" name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :head :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-options-node-proxy-with-path (name path2 &key path1)
  "connect OPTIONS requests to proxy of Node

    [*] path1: Path is the URL path to use for the current proxy request to node.

    [!] name: name of the Node

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/proxy/~A" name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :options :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-node-status (name &key pretty)
  "read status of the specified Node

    [*] pretty: If 'true', then the output is pretty printed.

    [!] name: name of the Node"
  (check-type pretty (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/status" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-node-status (node name &key pretty)
  "replace status of the specified Node

    [*] pretty: If 'true', then the output is pretty printed.

    [!] node: A value of type NODE

    [!] name: name of the Node"
  (check-type pretty (or string null))
  (check-type node node)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/status" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s node)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-node-status (patch name &key pretty)
  "partially update status of the specified Node

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] name: name of the Node"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/nodes/~A/status" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-persistent-volume-claim
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-persistent-volume-claim
       (persistent-volume-claim namespace &key pretty)
  "create a PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [!] persistent-volume-claim: A value of type PERSISTENT-VOLUME-CLAIM

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type persistent-volume-claim persistent-volume-claim)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s persistent-volume-claim)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-persistent-volume-claim
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-persistent-volume-claim-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/persistentvolumeclaims"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-persistent-volume-claim
       (namespace name &key pretty export exact)
  "read the specified PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PersistentVolumeClaim"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-persistent-volume-claim
       (persistent-volume-claim namespace name &key pretty)
  "replace the specified PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [!] persistent-volume-claim: A value of type PERSISTENT-VOLUME-CLAIM

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PersistentVolumeClaim"
  (check-type pretty (or string null))
  (check-type persistent-volume-claim persistent-volume-claim)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s persistent-volume-claim)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-persistent-volume-claim
       (patch namespace name &key pretty)
  "partially update the specified PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PersistentVolumeClaim"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-persistent-volume-claim
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PersistentVolumeClaim"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-persistent-volume-claim
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PersistentVolumeClaim"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/persistentvolumeclaims/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-persistent-volume-claim-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/persistentvolumeclaims")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-persistent-volume-claim-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/persistentvolumeclaims")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-persistent-volume-claim-status
       (namespace name &key pretty)
  "read status of the specified PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PersistentVolumeClaim"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-persistent-volume-claim-status
       (persistent-volume-claim namespace name &key pretty)
  "replace status of the specified PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [!] persistent-volume-claim: A value of type PERSISTENT-VOLUME-CLAIM

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PersistentVolumeClaim"
  (check-type pretty (or string null))
  (check-type persistent-volume-claim persistent-volume-claim)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s persistent-volume-claim)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-persistent-volume-claim-status
       (patch namespace name &key pretty)
  "partially update status of the specified PersistentVolumeClaim

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PersistentVolumeClaim"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/persistentvolumeclaims/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-persistent-volume
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/persistentvolumes")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-persistent-volume (persistent-volume &key pretty)
  "create a PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [!] persistent-volume: A value of type PERSISTENT-VOLUME"
  (check-type pretty (or string null))
  (check-type persistent-volume persistent-volume)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/persistentvolumes")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s persistent-volume)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-persistent-volume
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/persistentvolumes")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-persistent-volume-list
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/persistentvolumes")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-persistent-volume (name &key pretty export exact)
  "read the specified PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] name: name of the PersistentVolume"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/persistentvolumes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-persistent-volume (persistent-volume name &key pretty)
  "replace the specified PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [!] persistent-volume: A value of type PERSISTENT-VOLUME

    [!] name: name of the PersistentVolume"
  (check-type pretty (or string null))
  (check-type persistent-volume persistent-volume)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/persistentvolumes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s persistent-volume)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-persistent-volume (patch name &key pretty)
  "partially update the specified PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] name: name of the PersistentVolume"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/persistentvolumes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-persistent-volume
       (delete-options name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] name: name of the PersistentVolume"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/persistentvolumes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-persistent-volume
       (name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] name: name of the PersistentVolume"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/watch/persistentvolumes/~A" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-persistent-volume-status (name &key pretty)
  "read status of the specified PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [!] name: name of the PersistentVolume"
  (check-type pretty (or string null))
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/persistentvolumes/~A/status" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-persistent-volume-status (persistent-volume name &key pretty)
  "replace status of the specified PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [!] persistent-volume: A value of type PERSISTENT-VOLUME

    [!] name: name of the PersistentVolume"
  (check-type pretty (or string null))
  (check-type persistent-volume persistent-volume)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/persistentvolumes/~A/status" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s persistent-volume)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-persistent-volume-status (patch name &key pretty)
  "partially update status of the specified PersistentVolume

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] name: name of the PersistentVolume"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/persistentvolumes/~A/status" name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-pod
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/pods" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-pod (pod namespace &key pretty)
  "create a Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [!] pod: A value of type POD

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type pod pod)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/pods" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s pod)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-pod
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/pods" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-pod-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/watch/namespaces/~A/pods" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-pod (namespace name &key pretty export exact)
  "read the specified Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/pods/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-pod (pod namespace name &key pretty)
  "replace the specified Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [!] pod: A value of type POD

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type pretty (or string null))
  (check-type pod pod)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/pods/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s pod)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-pod (patch namespace name &key pretty)
  "partially update the specified Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/pods/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-pod
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/pods/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-pod
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/pods/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-pod-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/pods")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-pod-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/pods")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun connect-get-namespaced-pod-attach
       (namespace name &key stdin stdout stderr tty container)
  "connect GET requests to attach of Pod

    [*] stdin: Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.

    [*] stdout: Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.

    [*] stderr: Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.

    [*] tty: TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.

    [*] container: The container in which to execute the command. Defaults to only container if there is only one container in the pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type stdin (or boolean null))
  (check-type stdout (or boolean null))
  (check-type stderr (or boolean null))
  (check-type tty (or boolean null))
  (check-type container (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/attach" namespace name))
         (query nil))
    (when stdin (alexandria.0.dev:appendf query (list (cons "stdin" stdin))))
    (when stdout
      (alexandria.0.dev:appendf query (list (cons "stdout" stdout))))
    (when stderr
      (alexandria.0.dev:appendf query (list (cons "stderr" stderr))))
    (when tty (alexandria.0.dev:appendf query (list (cons "tty" tty))))
    (when container
      (alexandria.0.dev:appendf query (list (cons "container" container))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-post-namespaced-pod-attach
       (namespace name &key stdin stdout stderr tty container)
  "connect POST requests to attach of Pod

    [*] stdin: Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.

    [*] stdout: Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.

    [*] stderr: Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.

    [*] tty: TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.

    [*] container: The container in which to execute the command. Defaults to only container if there is only one container in the pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type stdin (or boolean null))
  (check-type stdout (or boolean null))
  (check-type stderr (or boolean null))
  (check-type tty (or boolean null))
  (check-type container (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/attach" namespace name))
         (query nil))
    (when stdin (alexandria.0.dev:appendf query (list (cons "stdin" stdin))))
    (when stdout
      (alexandria.0.dev:appendf query (list (cons "stdout" stdout))))
    (when stderr
      (alexandria.0.dev:appendf query (list (cons "stderr" stderr))))
    (when tty (alexandria.0.dev:appendf query (list (cons "tty" tty))))
    (when container
      (alexandria.0.dev:appendf query (list (cons "container" container))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun create-namespaced-pod-binding (binding namespace name &key pretty)
  "create binding of a Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [!] binding: A value of type BINDING

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Binding"
  (check-type pretty (or string null))
  (check-type binding binding)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/binding" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s binding)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun create-namespaced-pod-eviction (eviction namespace name &key pretty)
  "create eviction of a Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [!] eviction: A value of type EVICTION

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Eviction"
  (check-type pretty (or string null))
  (check-type eviction eviction)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/eviction" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s eviction)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun connect-get-namespaced-pod-exec
       (namespace name &key stdin stdout stderr tty container command)
  "connect GET requests to exec of Pod

    [*] stdin: Redirect the standard input stream of the pod for this call. Defaults to false.

    [*] stdout: Redirect the standard output stream of the pod for this call. Defaults to true.

    [*] stderr: Redirect the standard error stream of the pod for this call. Defaults to true.

    [*] tty: TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.

    [*] container: Container in which to execute the command. Defaults to only container if there is only one container in the pod.

    [*] command: Command is the remote command to execute. argv array. Not executed within a shell.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type stdin (or boolean null))
  (check-type stdout (or boolean null))
  (check-type stderr (or boolean null))
  (check-type tty (or boolean null))
  (check-type container (or string null))
  (check-type command (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/exec" namespace name))
         (query nil))
    (when stdin (alexandria.0.dev:appendf query (list (cons "stdin" stdin))))
    (when stdout
      (alexandria.0.dev:appendf query (list (cons "stdout" stdout))))
    (when stderr
      (alexandria.0.dev:appendf query (list (cons "stderr" stderr))))
    (when tty (alexandria.0.dev:appendf query (list (cons "tty" tty))))
    (when container
      (alexandria.0.dev:appendf query (list (cons "container" container))))
    (when command
      (alexandria.0.dev:appendf query (list (cons "command" command))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-post-namespaced-pod-exec
       (namespace name &key stdin stdout stderr tty container command)
  "connect POST requests to exec of Pod

    [*] stdin: Redirect the standard input stream of the pod for this call. Defaults to false.

    [*] stdout: Redirect the standard output stream of the pod for this call. Defaults to true.

    [*] stderr: Redirect the standard error stream of the pod for this call. Defaults to true.

    [*] tty: TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.

    [*] container: Container in which to execute the command. Defaults to only container if there is only one container in the pod.

    [*] command: Command is the remote command to execute. argv array. Not executed within a shell.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type stdin (or boolean null))
  (check-type stdout (or boolean null))
  (check-type stderr (or boolean null))
  (check-type tty (or boolean null))
  (check-type container (or string null))
  (check-type command (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/exec" namespace name))
         (query nil))
    (when stdin (alexandria.0.dev:appendf query (list (cons "stdin" stdin))))
    (when stdout
      (alexandria.0.dev:appendf query (list (cons "stdout" stdout))))
    (when stderr
      (alexandria.0.dev:appendf query (list (cons "stderr" stderr))))
    (when tty (alexandria.0.dev:appendf query (list (cons "tty" tty))))
    (when container
      (alexandria.0.dev:appendf query (list (cons "container" container))))
    (when command
      (alexandria.0.dev:appendf query (list (cons "command" command))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-namespaced-pod-log
       (namespace name
        &key pretty container follow previous since-seconds timestamps
        tail-lines limit-bytes)
  "read log of the specified Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [*] container: The container for which to stream logs. Defaults to only container if there is one container in the pod.

    [*] follow: Follow the log stream of the pod. Defaults to false.

    [*] previous: Return previous terminated container logs. Defaults to false.

    [*] since-seconds: A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.

    [*] timestamps: If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.

    [*] tail-lines: If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime

    [*] limit-bytes: If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type pretty (or string null))
  (check-type container (or string null))
  (check-type follow (or boolean null))
  (check-type previous (or boolean null))
  (check-type since-seconds (or integer null))
  (check-type timestamps (or boolean null))
  (check-type tail-lines (or integer null))
  (check-type limit-bytes (or integer null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/pods/~A/log" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when container
      (alexandria.0.dev:appendf query (list (cons "container" container))))
    (when follow
      (alexandria.0.dev:appendf query (list (cons "follow" follow))))
    (when previous
      (alexandria.0.dev:appendf query (list (cons "previous" previous))))
    (when since-seconds
      (alexandria.0.dev:appendf query
                                (list (cons "sinceSeconds" since-seconds))))
    (when timestamps
      (alexandria.0.dev:appendf query (list (cons "timestamps" timestamps))))
    (when tail-lines
      (alexandria.0.dev:appendf query (list (cons "tailLines" tail-lines))))
    (when limit-bytes
      (alexandria.0.dev:appendf query (list (cons "limitBytes" limit-bytes))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun connect-get-namespaced-pod-portforward (namespace name &key ports)
  "connect GET requests to portforward of Pod

    [*] ports: List of ports to forward Required when using WebSockets

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type ports (or integer null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/portforward" namespace
                  name))
         (query nil))
    (when ports (alexandria.0.dev:appendf query (list (cons "ports" ports))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-post-namespaced-pod-portforward (namespace name &key ports)
  "connect POST requests to portforward of Pod

    [*] ports: List of ports to forward Required when using WebSockets

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type ports (or integer null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/portforward" namespace
                  name))
         (query nil))
    (when ports (alexandria.0.dev:appendf query (list (cons "ports" ports))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun connect-get-namespaced-pod-proxy (namespace name &key path)
  "connect GET requests to proxy of Pod

    [*] path: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy" namespace name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-post-namespaced-pod-proxy (namespace name &key path)
  "connect POST requests to proxy of Pod

    [*] path: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy" namespace name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-put-namespaced-pod-proxy (namespace name &key path)
  "connect PUT requests to proxy of Pod

    [*] path: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy" namespace name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-patch-namespaced-pod-proxy (namespace name &key path)
  "connect PATCH requests to proxy of Pod

    [*] path: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy" namespace name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-delete-namespaced-pod-proxy (namespace name &key path)
  "connect DELETE requests to proxy of Pod

    [*] path: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy" namespace name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-head-namespaced-pod-proxy (namespace name &key path)
  "connect HEAD requests to proxy of Pod

    [*] path: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy" namespace name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :head :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-options-namespaced-pod-proxy (namespace name &key path)
  "connect OPTIONS requests to proxy of Pod

    [*] path: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy" namespace name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :options :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun connect-get-namespaced-pod-proxy-with-path
       (namespace name path2 &key path1)
  "connect GET requests to proxy of Pod

    [*] path1: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy/~A" namespace name
                  path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-post-namespaced-pod-proxy-with-path
       (namespace name path2 &key path1)
  "connect POST requests to proxy of Pod

    [*] path1: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy/~A" namespace name
                  path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-put-namespaced-pod-proxy-with-path
       (namespace name path2 &key path1)
  "connect PUT requests to proxy of Pod

    [*] path1: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy/~A" namespace name
                  path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-patch-namespaced-pod-proxy-with-path
       (namespace name path2 &key path1)
  "connect PATCH requests to proxy of Pod

    [*] path1: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy/~A" namespace name
                  path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-delete-namespaced-pod-proxy-with-path
       (namespace name path2 &key path1)
  "connect DELETE requests to proxy of Pod

    [*] path1: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy/~A" namespace name
                  path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-head-namespaced-pod-proxy-with-path
       (namespace name path2 &key path1)
  "connect HEAD requests to proxy of Pod

    [*] path1: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy/~A" namespace name
                  path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :head :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-options-namespaced-pod-proxy-with-path
       (namespace name path2 &key path1)
  "connect OPTIONS requests to proxy of Pod

    [*] path1: Path is the URL path to use for the current proxy request to pod.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/proxy/~A" namespace name
                  path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :options :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-namespaced-pod-status (namespace name &key pretty)
  "read status of the specified Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/status" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-pod-status (pod namespace name &key pretty)
  "replace status of the specified Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [!] pod: A value of type POD

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type pretty (or string null))
  (check-type pod pod)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/status" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s pod)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-pod-status (patch namespace name &key pretty)
  "partially update status of the specified Pod

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Pod"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/pods/~A/status" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-pod-template
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/podtemplates" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-pod-template (pod-template namespace &key pretty)
  "create a PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [!] pod-template: A value of type POD-TEMPLATE

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type pod-template pod-template)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/podtemplates" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s pod-template)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-pod-template
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/podtemplates" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-pod-template-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/podtemplates" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-pod-template (namespace name &key pretty export exact)
  "read the specified PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PodTemplate"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/podtemplates/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-pod-template
       (pod-template namespace name &key pretty)
  "replace the specified PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [!] pod-template: A value of type POD-TEMPLATE

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PodTemplate"
  (check-type pretty (or string null))
  (check-type pod-template pod-template)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/podtemplates/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s pod-template)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-pod-template (patch namespace name &key pretty)
  "partially update the specified PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PodTemplate"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/podtemplates/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-pod-template
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PodTemplate"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/podtemplates/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-pod-template
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the PodTemplate"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/podtemplates/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-pod-template-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/podtemplates")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-pod-template-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of PodTemplate

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/podtemplates")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-namespaced-replication-controller
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-replication-controller
       (replication-controller namespace &key pretty)
  "create a ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] replication-controller: A value of type REPLICATION-CONTROLLER

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type replication-controller replication-controller)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s replication-controller)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-replication-controller
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-replication-controller-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/replicationcontrollers"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-replication-controller
       (namespace name &key pretty export exact)
  "read the specified ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicationController"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-replication-controller
       (replication-controller namespace name &key pretty)
  "replace the specified ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] replication-controller: A value of type REPLICATION-CONTROLLER

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicationController"
  (check-type pretty (or string null))
  (check-type replication-controller replication-controller)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s replication-controller)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-replication-controller
       (patch namespace name &key pretty)
  "partially update the specified ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicationController"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-replication-controller
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicationController"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-replication-controller
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicationController"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/replicationcontrollers/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-replication-controller-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/replicationcontrollers")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-replication-controller-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/replicationcontrollers")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-replication-controller-scale
       (namespace name &key pretty)
  "read scale of the specified ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-replication-controller-scale
       (scale namespace name &key pretty)
  "replace scale of the specified ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] scale: A value of type SCALE

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type scale scale)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s scale)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-replication-controller-scale
       (patch namespace name &key pretty)
  "partially update scale of the specified ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-namespaced-replication-controller-status
       (namespace name &key pretty)
  "read status of the specified ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicationController"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-replication-controller-status
       (replication-controller namespace name &key pretty)
  "replace status of the specified ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] replication-controller: A value of type REPLICATION-CONTROLLER

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicationController"
  (check-type pretty (or string null))
  (check-type replication-controller replication-controller)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s replication-controller)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-replication-controller-status
       (patch namespace name &key pretty)
  "partially update status of the specified ReplicationController

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicationController"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/replicationcontrollers/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-resource-quota
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/resourcequotas" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-resource-quota (resource-quota namespace &key pretty)
  "create a ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [!] resource-quota: A value of type RESOURCE-QUOTA

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type resource-quota resource-quota)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/resourcequotas" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s resource-quota)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-resource-quota
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/resourcequotas" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-resource-quota-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/resourcequotas" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-resource-quota (namespace name &key pretty export exact)
  "read the specified ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ResourceQuota"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/resourcequotas/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-resource-quota
       (resource-quota namespace name &key pretty)
  "replace the specified ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [!] resource-quota: A value of type RESOURCE-QUOTA

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ResourceQuota"
  (check-type pretty (or string null))
  (check-type resource-quota resource-quota)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/resourcequotas/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s resource-quota)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-resource-quota (patch namespace name &key pretty)
  "partially update the specified ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ResourceQuota"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/resourcequotas/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-resource-quota
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ResourceQuota"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/resourcequotas/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-resource-quota
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ResourceQuota"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/resourcequotas/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-resource-quota-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/resourcequotas")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-resource-quota-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/resourcequotas")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-resource-quota-status (namespace name &key pretty)
  "read status of the specified ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ResourceQuota"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/resourcequotas/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-resource-quota-status
       (resource-quota namespace name &key pretty)
  "replace status of the specified ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [!] resource-quota: A value of type RESOURCE-QUOTA

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ResourceQuota"
  (check-type pretty (or string null))
  (check-type resource-quota resource-quota)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/resourcequotas/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s resource-quota)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-resource-quota-status
       (patch namespace name &key pretty)
  "partially update status of the specified ResourceQuota

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ResourceQuota"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/resourcequotas/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-secret
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/secrets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-secret (secret namespace &key pretty)
  "create a Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [!] secret: A value of type SECRET

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type secret secret)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/secrets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s secret)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-secret
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/secrets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-secret-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/watch/namespaces/~A/secrets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-secret (namespace name &key pretty export exact)
  "read the specified Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Secret"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/secrets/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-secret (secret namespace name &key pretty)
  "replace the specified Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [!] secret: A value of type SECRET

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Secret"
  (check-type pretty (or string null))
  (check-type secret secret)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/secrets/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s secret)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-secret (patch namespace name &key pretty)
  "partially update the specified Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Secret"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/secrets/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-secret
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Secret"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/secrets/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-secret
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Secret"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/secrets/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-secret-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/secrets")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-secret-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Secret

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/secrets")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-namespaced-service-account
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/serviceaccounts" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-service-account
       (service-account namespace &key pretty)
  "create a ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [!] service-account: A value of type SERVICE-ACCOUNT

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type service-account service-account)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/serviceaccounts" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s service-account)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-service-account
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/serviceaccounts" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-service-account-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/serviceaccounts" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-service-account
       (namespace name &key pretty export exact)
  "read the specified ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ServiceAccount"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/serviceaccounts/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-service-account
       (service-account namespace name &key pretty)
  "replace the specified ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [!] service-account: A value of type SERVICE-ACCOUNT

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ServiceAccount"
  (check-type pretty (or string null))
  (check-type service-account service-account)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/serviceaccounts/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s service-account)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-service-account (patch namespace name &key pretty)
  "partially update the specified ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ServiceAccount"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/serviceaccounts/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-service-account
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ServiceAccount"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/serviceaccounts/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-service-account
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ServiceAccount"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/serviceaccounts/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-service-account-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/serviceaccounts")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-service-account-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ServiceAccount

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/serviceaccounts")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-namespaced-service
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Service

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/services" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-service (service namespace &key pretty)
  "create a Service

    [*] pretty: If 'true', then the output is pretty printed.

    [!] service: A value of type SERVICE

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type service service)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/services" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s service)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-service-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Service

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/watch/namespaces/~A/services" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-service (namespace name &key pretty export exact)
  "read the specified Service

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/services/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-service (service namespace name &key pretty)
  "replace the specified Service

    [*] pretty: If 'true', then the output is pretty printed.

    [!] service: A value of type SERVICE

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type pretty (or string null))
  (check-type service service)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/services/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s service)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-service (patch namespace name &key pretty)
  "partially update the specified Service

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/services/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-service
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a Service

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/api/v1/namespaces/~A/services/~A" namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-service
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind Service

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/watch/namespaces/~A/services/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-service-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Service

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/services")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-service-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Service

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1/watch/services")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun connect-get-namespaced-service-proxy (namespace name &key path)
  "connect GET requests to proxy of Service

    [*] path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy" namespace
                  name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-post-namespaced-service-proxy (namespace name &key path)
  "connect POST requests to proxy of Service

    [*] path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy" namespace
                  name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-put-namespaced-service-proxy (namespace name &key path)
  "connect PUT requests to proxy of Service

    [*] path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy" namespace
                  name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-patch-namespaced-service-proxy (namespace name &key path)
  "connect PATCH requests to proxy of Service

    [*] path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy" namespace
                  name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-delete-namespaced-service-proxy (namespace name &key path)
  "connect DELETE requests to proxy of Service

    [*] path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy" namespace
                  name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-head-namespaced-service-proxy (namespace name &key path)
  "connect HEAD requests to proxy of Service

    [*] path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy" namespace
                  name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :head :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-options-namespaced-service-proxy (namespace name &key path)
  "connect OPTIONS requests to proxy of Service

    [*] path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type path (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy" namespace
                  name))
         (query nil))
    (when path (alexandria.0.dev:appendf query (list (cons "path" path))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :options :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun connect-get-namespaced-service-proxy-with-path
       (namespace name path2 &key path1)
  "connect GET requests to proxy of Service

    [*] path1: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy/~A" namespace
                  name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-post-namespaced-service-proxy-with-path
       (namespace name path2 &key path1)
  "connect POST requests to proxy of Service

    [*] path1: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy/~A" namespace
                  name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-put-namespaced-service-proxy-with-path
       (namespace name path2 &key path1)
  "connect PUT requests to proxy of Service

    [*] path1: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy/~A" namespace
                  name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-patch-namespaced-service-proxy-with-path
       (namespace name path2 &key path1)
  "connect PATCH requests to proxy of Service

    [*] path1: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy/~A" namespace
                  name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-delete-namespaced-service-proxy-with-path
       (namespace name path2 &key path1)
  "connect DELETE requests to proxy of Service

    [*] path1: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy/~A" namespace
                  name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-head-namespaced-service-proxy-with-path
       (namespace name path2 &key path1)
  "connect HEAD requests to proxy of Service

    [*] path1: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy/~A" namespace
                  name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :head :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun connect-options-namespaced-service-proxy-with-path
       (namespace name path2 &key path1)
  "connect OPTIONS requests to proxy of Service

    [*] path1: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service

    [!] path2: path to the resource"
  (check-type path1 (or string null))
  (check-type namespace string)
  (check-type name string)
  (check-type path2 string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/proxy/~A" namespace
                  name path))
         (query nil))
    (when path1 (alexandria.0.dev:appendf query (list (cons "path1" path1))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :options :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-namespaced-service-status (namespace name &key pretty)
  "read status of the specified Service

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/status" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-service-status (service namespace name &key pretty)
  "replace status of the specified Service

    [*] pretty: If 'true', then the output is pretty printed.

    [!] service: A value of type SERVICE

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type pretty (or string null))
  (check-type service service)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/status" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s service)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-service-status (patch namespace name &key pretty)
  "partially update status of the specified Service

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Service"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/api/v1/namespaces/~A/services/~A/status" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun get-api-resources ()
  "get available resources"
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/api/v1")
         (query nil))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-controller-revision
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/controllerrevisions"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-controller-revision
       (controller-revision namespace &key pretty)
  "create a ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [!] controller-revision: A value of type CONTROLLER-REVISION

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type controller-revision controller-revision)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/controllerrevisions"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s controller-revision)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-controller-revision
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/controllerrevisions"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-controller-revision-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/watch/namespaces/~A/controllerrevisions"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-controller-revision
       (namespace name &key pretty export exact)
  "read the specified ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ControllerRevision"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/controllerrevisions/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-controller-revision
       (controller-revision namespace name &key pretty)
  "replace the specified ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [!] controller-revision: A value of type CONTROLLER-REVISION

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ControllerRevision"
  (check-type pretty (or string null))
  (check-type controller-revision controller-revision)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/controllerrevisions/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s controller-revision)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-controller-revision (patch namespace name &key pretty)
  "partially update the specified ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ControllerRevision"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/controllerrevisions/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-controller-revision
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ControllerRevision"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/controllerrevisions/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-controller-revision
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ControllerRevision"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil
                  "/apis/apps/v1/watch/namespaces/~A/controllerrevisions/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-controller-revision-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/controllerrevisions")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-controller-revision-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ControllerRevision

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/watch/controllerrevisions")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-namespaced-daemon-set
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/apis/apps/v1/namespaces/~A/daemonsets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-daemon-set (daemon-set namespace &key pretty)
  "create a DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] daemon-set: A value of type DAEMON-SET

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type daemon-set daemon-set)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/apis/apps/v1/namespaces/~A/daemonsets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s daemon-set)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-daemon-set
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path (format nil "/apis/apps/v1/namespaces/~A/daemonsets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-daemon-set-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/watch/namespaces/~A/daemonsets"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-daemon-set (namespace name &key pretty export exact)
  "read the specified DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the DaemonSet"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/daemonsets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-daemon-set (daemon-set namespace name &key pretty)
  "replace the specified DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] daemon-set: A value of type DAEMON-SET

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the DaemonSet"
  (check-type pretty (or string null))
  (check-type daemon-set daemon-set)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/daemonsets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s daemon-set)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-daemon-set (patch namespace name &key pretty)
  "partially update the specified DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the DaemonSet"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/daemonsets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-daemon-set
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the DaemonSet"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/daemonsets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-daemon-set
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the DaemonSet"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/watch/namespaces/~A/daemonsets/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-daemon-set-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/daemonsets")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-daemon-set-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/watch/daemonsets")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-daemon-set-status (namespace name &key pretty)
  "read status of the specified DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the DaemonSet"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/daemonsets/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-daemon-set-status
       (daemon-set namespace name &key pretty)
  "replace status of the specified DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] daemon-set: A value of type DAEMON-SET

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the DaemonSet"
  (check-type pretty (or string null))
  (check-type daemon-set daemon-set)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/daemonsets/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s daemon-set)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-daemon-set-status (patch namespace name &key pretty)
  "partially update status of the specified DaemonSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the DaemonSet"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/daemonsets/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-deployment
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-deployment (deployment namespace &key pretty)
  "create a Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] deployment: A value of type DEPLOYMENT

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type deployment deployment)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s deployment)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-deployment
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-deployment-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/watch/namespaces/~A/deployments"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-deployment (namespace name &key pretty export exact)
  "read the specified Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Deployment"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-deployment (deployment namespace name &key pretty)
  "replace the specified Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] deployment: A value of type DEPLOYMENT

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Deployment"
  (check-type pretty (or string null))
  (check-type deployment deployment)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s deployment)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-deployment (patch namespace name &key pretty)
  "partially update the specified Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Deployment"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-deployment
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Deployment"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-deployment
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Deployment"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/watch/namespaces/~A/deployments/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-deployment-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/deployments")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-deployment-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/watch/deployments")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-deployment-scale (namespace name &key pretty)
  "read scale of the specified Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-deployment-scale (scale namespace name &key pretty)
  "replace scale of the specified Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] scale: A value of type SCALE

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type scale scale)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s scale)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-deployment-scale (patch namespace name &key pretty)
  "partially update scale of the specified Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-namespaced-deployment-status (namespace name &key pretty)
  "read status of the specified Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Deployment"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-deployment-status
       (deployment namespace name &key pretty)
  "replace status of the specified Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] deployment: A value of type DEPLOYMENT

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Deployment"
  (check-type pretty (or string null))
  (check-type deployment deployment)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s deployment)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-deployment-status (patch namespace name &key pretty)
  "partially update status of the specified Deployment

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Deployment"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/deployments/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-replica-set
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-replica-set (replica-set namespace &key pretty)
  "create a ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] replica-set: A value of type REPLICA-SET

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type replica-set replica-set)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s replica-set)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-replica-set
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-replica-set-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/watch/namespaces/~A/replicasets"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-replica-set (namespace name &key pretty export exact)
  "read the specified ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicaSet"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-replica-set (replica-set namespace name &key pretty)
  "replace the specified ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] replica-set: A value of type REPLICA-SET

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicaSet"
  (check-type pretty (or string null))
  (check-type replica-set replica-set)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s replica-set)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-replica-set (patch namespace name &key pretty)
  "partially update the specified ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicaSet"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-replica-set
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicaSet"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-replica-set
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicaSet"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/watch/namespaces/~A/replicasets/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-replica-set-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/replicasets")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-replica-set-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/watch/replicasets")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-replica-set-scale (namespace name &key pretty)
  "read scale of the specified ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-replica-set-scale (scale namespace name &key pretty)
  "replace scale of the specified ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] scale: A value of type SCALE

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type scale scale)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s scale)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-replica-set-scale (patch namespace name &key pretty)
  "partially update scale of the specified ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-namespaced-replica-set-status (namespace name &key pretty)
  "read status of the specified ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicaSet"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-replica-set-status
       (replica-set namespace name &key pretty)
  "replace status of the specified ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] replica-set: A value of type REPLICA-SET

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicaSet"
  (check-type pretty (or string null))
  (check-type replica-set replica-set)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s replica-set)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-replica-set-status (patch namespace name &key pretty)
  "partially update status of the specified ReplicaSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the ReplicaSet"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/replicasets/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun list-namespaced-stateful-set
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun create-namespaced-stateful-set (stateful-set namespace &key pretty)
  "create a StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] stateful-set: A value of type STATEFUL-SET

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type stateful-set stateful-set)
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :post :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s stateful-set)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun deletecollection-namespaced-stateful-set
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "delete collection of StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets" namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-stateful-set-list
       (namespace
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/watch/namespaces/~A/statefulsets"
                  namespace))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-stateful-set (namespace name &key pretty export exact)
  "read the specified StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] export: Should this value be exported.  Export strips fields that a user can not specify.

    [*] exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the StatefulSet"
  (check-type pretty (or string null))
  (check-type export (or boolean null))
  (check-type exact (or boolean null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when export
      (alexandria.0.dev:appendf query (list (cons "export" export))))
    (when exact (alexandria.0.dev:appendf query (list (cons "exact" exact))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-stateful-set
       (stateful-set namespace name &key pretty)
  "replace the specified StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] stateful-set: A value of type STATEFUL-SET

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the StatefulSet"
  (check-type pretty (or string null))
  (check-type stateful-set stateful-set)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s stateful-set)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-stateful-set (patch namespace name &key pretty)
  "partially update the specified StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the StatefulSet"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun delete-namespaced-stateful-set
       (delete-options namespace name
        &key pretty grace-period-seconds orphan-dependents propagation-policy)
  "delete a StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] delete-options: A value of type DELETE-OPTIONS

    [*] grace-period-seconds: The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.

    [*] orphan-dependents: Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.

    [*] propagation-policy: Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the StatefulSet"
  (check-type pretty (or string null))
  (check-type delete-options delete-options)
  (check-type grace-period-seconds (or integer null))
  (check-type orphan-dependents (or boolean null))
  (check-type propagation-policy (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A" namespace
                  name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when grace-period-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "gracePeriodSeconds"
                                       grace-period-seconds))))
    (when orphan-dependents
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "orphanDependents" orphan-dependents))))
    (when propagation-policy
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "propagationPolicy"
                                       propagation-policy))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :delete :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s delete-options)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-namespaced-stateful-set
       (namespace name
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch changes to an object of kind StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the StatefulSet"
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/watch/namespaces/~A/statefulsets/~A"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun list-stateful-set-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "list or watch objects of kind StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/statefulsets")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun watch-stateful-set-list-for-all-namespaces
       (
        &key pretty label-selector field-selector include-uninitialized watch
        resource-version timeout-seconds limit continue)
  "watch individual changes to a list of StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [*] label-selector: A selector to restrict the list of returned objects by their labels. Defaults to everything.

    [*] field-selector: A selector to restrict the list of returned objects by their fields. Defaults to everything.

    [*] include-uninitialized: If true, partially initialized resources are included in the response.

    [*] watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.

    [*] resource-version: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.

    [*] timeout-seconds: Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.

    [*] limit: limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.

The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.

    [*] continue: The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications."
  (check-type pretty (or string null))
  (check-type label-selector (or string null))
  (check-type field-selector (or string null))
  (check-type include-uninitialized (or boolean null))
  (check-type watch (or boolean null))
  (check-type resource-version (or string null))
  (check-type timeout-seconds (or integer null))
  (check-type limit (or integer null))
  (check-type continue (or string null))
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1/watch/statefulsets")
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (when label-selector
      (alexandria.0.dev:appendf query
                                (list (cons "labelSelector" label-selector))))
    (when field-selector
      (alexandria.0.dev:appendf query
                                (list (cons "fieldSelector" field-selector))))
    (when include-uninitialized
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "includeUninitialized"
                                       include-uninitialized))))
    (when watch (alexandria.0.dev:appendf query (list (cons "watch" watch))))
    (when resource-version
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "resourceVersion" resource-version))))
    (when timeout-seconds
      (alexandria.0.dev:appendf query
                                (list
                                 (cons "timeoutSeconds" timeout-seconds))))
    (when limit (alexandria.0.dev:appendf query (list (cons "limit" limit))))
    (when continue
      (alexandria.0.dev:appendf query (list (cons "continue" continue))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        stream))))


(defun read-namespaced-stateful-set-scale (namespace name &key pretty)
  "read scale of the specified StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-stateful-set-scale (scale namespace name &key pretty)
  "replace scale of the specified StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] scale: A value of type SCALE

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type scale scale)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s scale)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-stateful-set-scale (patch namespace name &key pretty)
  "partially update scale of the specified StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the Scale"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A/scale"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun read-namespaced-stateful-set-status (namespace name &key pretty)
  "read status of the specified StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the StatefulSet"
  (check-type pretty (or string null))
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun replace-namespaced-stateful-set-status
       (stateful-set namespace name &key pretty)
  "replace status of the specified StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] stateful-set: A value of type STATEFUL-SET

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the StatefulSet"
  (check-type pretty (or string null))
  (check-type stateful-set stateful-set)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :put :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s)
                                 (marshal s stateful-set)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

(defun patch-namespaced-stateful-set-status (patch namespace name &key pretty)
  "partially update status of the specified StatefulSet

    [*] pretty: If 'true', then the output is pretty printed.

    [!] patch: A value of type PATCH

    [!] namespace: object name and auth scope, such as for teams and projects

    [!] name: name of the StatefulSet"
  (check-type pretty (or string null))
  (check-type patch patch)
  (check-type namespace string)
  (check-type name string)
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path
          (format nil "/apis/apps/v1/namespaces/~A/statefulsets/~A/status"
                  namespace name))
         (query nil))
    (when pretty
      (alexandria.0.dev:appendf query (list (cons "pretty" pretty))))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :patch :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key* :content
                               (with-output-to-string (s) (marshal s patch)))
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))


(defun get-api-resources ()
  "get available resources"
  (let* ((scheme *api-endpoint-scheme*)
         (host *api-endpoint-host*)
         (port *api-endpoint-port*)
         (path "/apis/apps/v1")
         (query nil))
    (let* ((query-string (quri.encode:url-encode-params query))
           (url
            (format nil "~A://~A:~D~A~:[~;?~A~]" scheme host port path query
                    query-string)))
      (multiple-value-bind (stream status-code headers)
          (drakma:http-request url :method :get :content-type
                               "application/json" :connection-timeout 5
                               :want-stream t :ca-file
                               *cluster-certificate-authority* :certificate
                               *client-certificate* :key *client-key*)
        (let* ((response
                (alexandria.0.dev:read-stream-content-into-string stream))
               (object (yason:parse response)))
          (decode-object (gethash "kind" object) object))))))

